// Generated by Avo VERSION 107.29.0. You should never have to make changes to this file.
// If you find yourself in the situation where you have to edit the file please contact us at hi@avo.app.
// If you encounter a git conflict in this file run `avo pull` and it will be resolved automatically.
/* tslint:disable */
/* eslint-disable */

export enum AvoEnv {
  Prod = "prod",
  Dev = "dev",
}

export interface CustomDestination {
  make?(env: string, apiKey: string): void;
  logEvent?: (userId: string, eventName: string, eventProperties: object) => Promise<void>;
  setUserProperties?: (userId: string, userProperties: object) => Promise<void>;
  logPage?: (userId: string, pageName: string, eventProperties: object) => Promise<void>;
  revenue?: (userId: string, amount: number, eventProperties: object) => Promise<void>;
}

// @ts-ignore
interface AvoAssertMessage {
  eventName?: string;
  tag?: string;
  propertyId?: string;
  message?: string;
  additionalProperties?: string[],
  shape?: object,
  shapeUserProps?: object,
  actualType?: string
}

let __AVO_ENV__: AvoEnv | null = null;
// @ts-ignore
let __AVO_NOOP__: boolean = false;
// @ts-ignore
let __AVO_LOGGER__: AvoLogger | null = null;
// @ts-ignore
let __STRICT__: boolean | null = null;
// @ts-ignore
let __REPORT_FAILURE_AS__: 'error' | 'warn' | 'log' | null = null;
export const avoInspectorApiKey = "3UWtteG9HenZ825cYoYr";
// @ts-ignore
interface AvoInspector {}
let __INSPECTOR__: AvoInspector | null = null;


// polyfill Object.assign
// @ts-ignore
declare interface ObjectConstructor {
  assign: any;
}
// @ts-ignore
if (typeof Object.assign !== 'function') {
  // Must be writable: true, enumerable: false, configurable: true
  Object.defineProperty(Object, "assign", {
    value: function assign(target: any, _varArgs: any) { // .length of function is 2
      if (target == null) { // TypeError if undefined or null
        throw new TypeError('Cannot convert undefined or null to object');
      }

      let to = Object(target);

      for (let index = 1; index < arguments.length; index++) {
        let nextSource = arguments[index];

        if (nextSource != null) { // Skip over if undefined or null
          for (let nextKey in nextSource) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true
  });
}

interface AvoLogger {
  logDebug(env: AvoEnv | null, message: string): boolean;
  logWarn(env: AvoEnv | null, message: string): boolean;
  logError(env: AvoEnv | null, error: string): boolean;
}

let InternalAvoLogger: any = {
  logEventSent: function logEventSent(eventName: string, eventProperties: any, userProperties: any) {
    const message = "Event Sent:" + eventName + "Event Props:" + JSON.stringify(eventProperties) + "User Props:" + JSON.stringify(userProperties);

    if (__AVO_LOGGER__ && __AVO_LOGGER__.logDebug && __AVO_LOGGER__.logDebug(__AVO_ENV__, message)) {
      return
    }
    typeof console !== 'undefined' && console.log("[avo] Event Sent:", eventName, "Event Props:", eventProperties, "User Props:", userProperties);
  },

  log: function log(message: string) {
    if (__AVO_LOGGER__ && __AVO_LOGGER__.logDebug && __AVO_LOGGER__.logDebug(__AVO_ENV__, message)) {
      return
    }
    typeof console !== 'undefined' && console.log("[avo] " + message);
  },

  warn: function warn(message: string) {
    if (__AVO_LOGGER__ && __AVO_LOGGER__.logWarn && __AVO_LOGGER__.logWarn(__AVO_ENV__, message)) {
      return
    }
    typeof console !== 'undefined' && console.warn("[avo] " + message);
  },

  error: function error(message: string, error: string) {
    if (__AVO_LOGGER__ && __AVO_LOGGER__.logError && __AVO_LOGGER__.logError(__AVO_ENV__, message + error)) {
      return
    }
    typeof console !== 'undefined' && console.error("[avo] " + message, error);
  }
};

// @ts-ignore
let array_difference: any;
// @ts-ignore
let AvoAssert: any;
array_difference = function array_difference(a1: any[], a2: any[]) {
  let result: any[] = [];
  for (let i = 0; i < a1.length; i++) {
    if (a2.indexOf(a1[i]) === -1) {
      result.push(a1[i]);
    }
  }
  return result;
}

AvoAssert = {
  assertObject: function assertObject(propertyId: string, propName: string, obj: object) {
    if (typeof obj !== 'object') {
      let message = propName +
          ' should be of type object but you provided type ' +
          typeof obj +
          ' with value ' +
          JSON.stringify(obj);
      return [{tag: 'expectedObjectType', propertyId, message, actualType: typeof obj}];
    } else {
      return [];
    }
  },

  assertString: function assertString(propertyId: string, propName: string, str: string) {
    if (typeof str !== 'string') {
      let message = propName +
          ' should be of type string but you provided type ' +
          typeof str +
          ' with value ' +
          JSON.stringify(str);
      return [{tag: 'expectedStringType', propertyId, message, actualType: typeof str}];
    } else {
      return [];
    }
  },

  assertInt: function assertInt(propertyId: string, propName: string, int: number) {
    if (typeof int === 'number' && int !== Math.round(int)) {
      let message = propName +
          ' should be of type int but you provided type float with value ' +
          JSON.stringify(int);
      return [{tag: 'expectedIntType', propertyId, message, actualType: 'float'}];
    } else if (typeof int !== 'number') {
      let message = propName +
          ' should be of type int but you provided type ' +
          typeof int +
          ' with value ' +
          JSON.stringify(int);
      return [{tag: 'expectedIntType', propertyId, message, actualType: typeof int}];
    } else {
      return [];
    }
  },

  assertLong: function assertLong(propertyId: string, propName: string, long: number) {
    if (typeof long === 'number' && long !== Math.round(long)) {
      let message = propName +
          ' should be of type long but you provided type float with value ' +
          JSON.stringify(long);
      return [{tag: 'expectedLongType', propertyId, message, actualType: 'float'}];
    } else if (typeof long !== 'number') {
      let message = propName +
          ' should be of type long but you provided type ' +
          typeof long +
          ' with value ' +
          JSON.stringify(long);
      return [{tag: 'expectedLongType', propertyId, message, actualType: typeof long}];
    } else {
      return [];
    }
  },

  assertFloat: function assertFloat(propertyId: string, propName: string, float: number) {
    if (typeof float !== 'number') {
      let message = propName +
          ' should be of type float but you provided type ' +
          typeof float +
          ' with value ' +
          JSON.stringify(float);
      return [{tag: 'expectedFloatType', propertyId, message, actualType: typeof float}];
    } else {
      return [];
    }
  },

  assertBool: function assertBool(propertyId: string, propName: string, bool: boolean) {
    if (typeof bool !== 'boolean') {
      let message = propName +
          ' should be of type boolean but you provided type ' +
          typeof bool +
          ' with value ' +
          JSON.stringify(bool);
      return [{tag: 'expectedBoolType', propertyId, message, actualType: typeof bool}];
    } else {
      return [];
    }
  },

  assertMax: function assertMax(
    propertyId: string,
    propName: string,
    max: number,
    value: number
  ) {
    if (value > max) {
      let message = propName +
        ' has a maximum value of ' +
        max +
        ' but you provided the value ' +
        JSON.stringify(value);
      return [{tag: 'expectedMax', propertyId, message}];
    } else {
      return [];
    }
  },

  assertMin: function assertMin(
    propertyId: string,
    propName: string,
    min: number,
    value: number
  ) {
    if (value < min) {
      let message = propName +
        ' has a minimum value of ' +
        min +
        ' but you provided the value ' +
        JSON.stringify(value);
      return [{tag: 'expectedMin', propertyId, message}];
    } else {
      return [];
    }
  },

  assertList: function assertList(propertyId: string, propName: string, value: any) {
    if (!Array.isArray(value)) {
      let message = propName + ' should be of type list but you provided type ' + typeof value;
      return [{tag: 'expectedList', propertyId, message}];
    } else {
      return [];
    }
  },

  assertNoAdditionalProperties: function assertNoAdditionalProperties(eventName: string, input: string[], spec: string[]) {
    let additionalKeys = array_difference(input, spec);
    if (additionalKeys.length) {
      let message = "Additional properties when sending event " + eventName + ": " + JSON.stringify(additionalKeys);
      return [{tag: 'expectedNoAdditionalProperties', additionalProperties: additionalKeys, message: message}];
    } else {
      return [];
    }
  },

  assertNoAdditionalUserProperties: function assertNoAdditionalProperties(eventName: string, input: string[], spec: string[]) {
    let additionalKeys = array_difference(input, spec);
    if (additionalKeys.length) {
      let message = "Additional user properties when sending event " + eventName + ": " + JSON.stringify(additionalKeys);
      return [{tag: 'expectedNoAdditionalUserProperties', additionalProperties: additionalKeys, message: message}];
    } else {
      return [];
    }
  },
};

let _avo_invoke: any;
let _avo_invoke_meta: any;
let _avo_sampling_rate = 1.0;
function _avo_invoke_payload(body: object) {
  // @ts-ignore
  if (_avo_sampling_rate > 0) {
    // @ts-ignore
    if (Math.random() < _avo_sampling_rate) {
      // @ts-ignore
      const data = JSON.stringify(body);
      let options = {
        hostname: 'api.avo.app',
        port: 443,
        path: '/i',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': Buffer.byteLength(data)
        }
      };
      let req = require('https').request(options, (res: any) => {
        const chunks: any = [];
        res.on('data', (data: any) => chunks.push(data));
        res.on('end', () => {
          try {
            // @ts-ignore
            const data = JSON.parse(Buffer.concat(chunks).toString());
            // @ts-ignore
            _avo_sampling_rate = data.sa;
          } catch(e) {}
        });
      });
      req.write(data);
      // @ts-ignore
      req.on('error', () => { });
      req.end();
    }
  }
}

_avo_invoke = function _avo_invoke(env: string, eventId: string, hash: string, messages: {tag: string, propertyId: string}[], origin: string) {
  try {
    _avo_invoke_payload({
      "ac": "U4a4TSJXCxaOuqumiD5Y",
      "br": "ZbBYeviBz",
      "en": env,
      "ev": eventId,
      "ha": hash,
      "sc": "fwtXqAc0fCLy7b7oGW40",
      "se": (new Date()).toISOString(),
      "so": "xOUFa-ew2",
      "va": messages.length === 0,
      "me": messages,
      "or": origin
    });
  } catch (e) { if (env !== AvoEnv.Prod) { throw e; } else { InternalAvoLogger.error("", e); } }
}

_avo_invoke_meta = function _avo_invoke_meta(env: string, type: string, messages: {tag: string, propertyId: string}[], origin: string) {
  try {
    _avo_invoke_payload({
      "ac": "U4a4TSJXCxaOuqumiD5Y",
      "br": "ZbBYeviBz",
      "en": env,
      "ty": type,
      "sc": "fwtXqAc0fCLy7b7oGW40",
      "se": (new Date()).toISOString(),
      "so": "xOUFa-ew2",
      "va": messages.length === 0,
      "me": messages,
      "or": origin
    });
  } catch (e) { if (env !== AvoEnv.Prod) { throw e; } else { InternalAvoLogger.error("", e); } }
}


export const SignInError = {
  'UNKNOWN': 'Unknown',
  'WRONG_PASSWORD': 'Wrong Password',
  'USER_NOT_FOUND': 'User Not Found',
  'USER_DISABLED': 'User Disabled',
  'INVALID_EMAIL': 'Invalid Email',
} as const;
export type SignInErrorType = typeof SignInError;
export type SignInErrorValueType = SignInErrorType[keyof SignInErrorType];

export const Client = {
  'CLOUD_FUNCTIONS': 'Cloud Functions',
  'WEB': 'Web',
  'LANDING_PAGE': 'Landing Page',
  'CLI': 'Cli',
  'WEB_DEBUGGER': 'Web Debugger',
  'ANDROID_DEBUGGER': 'Android Debugger',
  'IOS_DEBUGGER': 'Ios Debugger',
  'REACT_NATIVE_DEBUGGER_IOS': 'React Native Debugger (ios)',
  'REACT_NATIVE_DEBUGGER_ANDROID': 'React Native Debugger (android)',
  'DOCS': 'Docs',
  'PUBLISHING_WORKER': 'Publishing Worker',
} as const;
export type ClientType = typeof Client;
export type ClientValueType = ClientType[keyof ClientType];

export const AuthenticationMethod = {
  'GOOGLE': 'Google',
  'EMAIL': 'Email',
  'SSO': 'SSO',
} as const;
export type AuthenticationMethodType = typeof AuthenticationMethod;
export type AuthenticationMethodValueType = AuthenticationMethodType[keyof AuthenticationMethodType];

export const CliAction = {
  'LOGIN': 'Login',
  'LOGOUT': 'Logout',
  'PULL': 'Pull',
  'CHECKOUT': 'Checkout',
  'INIT': 'Init',
  'STATUS': 'Status',
  'BRANCH': 'Branch',
  'EDIT': 'Edit',
  'WHOAMI': 'Whoami',
  'SOURCE': 'Source',
  'SOURCE_ADD': 'Source Add',
  'SOURCE_REMOVE': 'Source Remove',
  'MERGE': 'Merge',
  'CONFLICT': 'Conflict',
} as const;
export type CliActionType = typeof CliAction;
export type CliActionValueType = CliActionType[keyof CliActionType];

let sysClient: any;
let sysVersion: any;

export function setSystemProperties(properties: {client: ClientValueType;
  version: string}) {
  if (properties.client !== null && properties.client !== undefined) {
    sysClient = properties.client;
  }
  if (properties.version !== null && properties.version !== undefined) {
    sysVersion = properties.version;
  }
}

let CustomNodeJS: any;

export function initAvo(options: {env: AvoEnv; strict?: boolean;
  noop?: boolean; reportFailureAs?: 'error' | 'warn' | 'log';
  inspector?: AvoInspector; avoLogger?: AvoLogger},
  systemProperties: {client: ClientValueType; version: string},
  destinationOptions: any, CustomNodeJSDestination: CustomDestination) {
  if (__AVO_ENV__ !== null) {
    return;
  }
  __AVO_ENV__ = options.env;
  if (options.avoLogger !== undefined) {
    __AVO_LOGGER__ = options.avoLogger;
  }
  if (options.noop === true) {
    __AVO_NOOP__ = true;
  }
  if (__AVO_NOOP__ && __AVO_ENV__ == AvoEnv.Prod) {
    InternalAvoLogger.warn("[avo] ****************************************************");
    InternalAvoLogger.warn("[avo] WARNING Avo cannot be initialized in noop mode in production:");
    InternalAvoLogger.warn("[avo] - Overwriting configuration with noop=false.");
    InternalAvoLogger.warn("[avo] - Please reach out if you want to be able to run Avo in production mode with noop=true");
    InternalAvoLogger.warn("[avo] ****************************************************");
    __AVO_NOOP__ = false;
  }
  if (__AVO_NOOP__) {
    InternalAvoLogger.log("[avo] ****************************************************");
    InternalAvoLogger.log("[avo] Avo is now initialized in noop mode. This means:");
    InternalAvoLogger.log("[avo] - No events will be sent");
    InternalAvoLogger.log("[avo] - No network requests are made");
    InternalAvoLogger.log("[avo] ****************************************************");
  }
  if (options.strict !== undefined) {
    __STRICT__ = options.strict !== false;
  }
  if (options.reportFailureAs !== undefined) {
    __REPORT_FAILURE_AS__ = options.reportFailureAs;
  }
  if (!__AVO_NOOP__ && options.inspector !== undefined) {
    __INSPECTOR__ = options.inspector;
  } else if (__AVO_ENV__ !== 'prod') {
    InternalAvoLogger.warn("[avo] Avo Inspector not provided in initAvo() call");
  }

  setSystemProperties(systemProperties);

  destinationOptions = destinationOptions || {};

  if (!__AVO_NOOP__) {
    if (__AVO_ENV__ === AvoEnv.Prod) {
    }
    if (__AVO_ENV__ === AvoEnv.Dev) {
    }

    CustomNodeJS = CustomNodeJSDestination;
    if (__AVO_ENV__ === 'prod') {
      CustomNodeJS && CustomNodeJS.make && CustomNodeJS.make(__AVO_ENV__, "2");
    } else if (__AVO_ENV__ === 'dev') {
      CustomNodeJS && CustomNodeJS.make && CustomNodeJS.make(__AVO_ENV__, "1");
    } else {
      console[__REPORT_FAILURE_AS__ || 'error']("[avo] No staging key is set for Custom Node JS. Head to destination settings in Avo to set a staging key.");
      CustomNodeJS && CustomNodeJS.make && CustomNodeJS.make(__AVO_ENV__, null);
    }
    if (__AVO_ENV__ === AvoEnv.Dev) {
      // debug console in Avo
      _avo_invoke_meta(__AVO_ENV__, 'init', [], 'init');
    }
  }
}

export function setAvoLogger(avoLogger: AvoLogger | null) {
  __AVO_LOGGER__ = avoLogger;
}

export interface SignedInProperties {
  userId_: string;
  email: string;
  authenticationMethod: AuthenticationMethodValueType;
}
/**
 * Signed In: Sent when user successfully signs in or when we successfully authenticate a user.
 *
 * @param properties the properties associatied with this event
 * @param properties.userId_: The value used to identify the user. Make sure it's a unique sequence of characters used to identify the user.
 * @param properties.email: The user's email
 * @param properties.authenticationMethod: Type of authentication method used by user logging in or signing up
 *
 * @see {@link https://www.avo.app/schemas/fwtXqAc0fCLy7b7oGW40/branches/ZbBYeviBz/events/54e92613-090c-4f0b-afeb-ed720eff3422}
 */
export function signedIn(properties: SignedInProperties) {
  // assert properties
  if (__AVO_ENV__ !== AvoEnv.Prod) {
    let messages: AvoAssertMessage[] = [];
    // debug console in Avo
    if (!__AVO_NOOP__) {
      _avo_invoke(__AVO_ENV__, "54e92613-090c-4f0b-afeb-ed720eff3422", "2fec10106ad560f43f307ffdc820e3bd7a474585f9c62ee39961730c35694cb1", messages.map(m => Object.assign({}, {tag: m.tag, propertyId: m.propertyId, additionalProperties: m.additionalProperties, actualType: m.actualType})), 'event');
    }
    InternalAvoLogger.logEventSent("Signed In", {
      "Authentication Method": properties.authenticationMethod,
      "Client": sysClient,
      "Version": sysVersion,
      }, {
      "Email": properties.email,
      });
  }

  // @ts-ignore
  let eventPropertiesCustomNodeJS: any = {};
  eventPropertiesCustomNodeJS["Authentication Method"] = properties.authenticationMethod;
  eventPropertiesCustomNodeJS["Client"] = sysClient;
  eventPropertiesCustomNodeJS["Version"] = sysVersion;

  // @ts-ignore
  let userPropertiesCustomNodeJS: any = {};
  userPropertiesCustomNodeJS["Email"] = properties.email;

  if (!__AVO_NOOP__) {
    return Promise.all([
      // report to Avo Inspector
      __INSPECTOR__ != null
        // @ts-ignore
        ? __INSPECTOR__._avoFunctionTrackSchemaFromEvent("Signed In", {
        "Authentication Method": properties.authenticationMethod,
        "Client": sysClient,
        "Version": sysVersion,
        }, "54e92613-090c-4f0b-afeb-ed720eff3422", "2fec10106ad560f43f307ffdc820e3bd7a474585f9c62ee39961730c35694cb1")
      : Promise.resolve(),
      // destination CustomNodeJS
      CustomNodeJS.setUserProperties(properties.userId_, (Object as any).assign({}, userPropertiesCustomNodeJS)),
      CustomNodeJS.logEvent(properties.userId_, "Signed In", (Object as any).assign({}, eventPropertiesCustomNodeJS)),
    ]);
  } else {
    // do nothing
    return new Promise((resolve: any) => { resolve(null); });
  }
}

export interface SignInFailedProperties {
  userId_: string;
  signInError: SignInErrorValueType;
  emailInput: string | null | undefined;
}
/**
 * Sign In Failed: Sent when sign in request fails.
 *
 * @param properties the properties associatied with this event
 * @param properties.userId_: User Id is required for server sources.
 * @param properties.signInError: no description
 * @param properties.emailInput: The email address that is put into the email input on the landing page
 *
 * @see {@link https://www.avo.app/schemas/fwtXqAc0fCLy7b7oGW40/branches/ZbBYeviBz/events/7aa64217-bb89-44f5-9a68-f3bc0255a864}
 */
export function signInFailed(properties: SignInFailedProperties) {
  // assert properties
  if (__AVO_ENV__ !== AvoEnv.Prod) {
    let messages: AvoAssertMessage[] = [];
    // debug console in Avo
    if (!__AVO_NOOP__) {
      _avo_invoke(__AVO_ENV__, "7aa64217-bb89-44f5-9a68-f3bc0255a864", "ddc8c1ee0b5dbe58efd0d44d6d4dd8c2bc61bf1d64c7c8f74ea1f50d5b24b2ed", messages.map(m => Object.assign({}, {tag: m.tag, propertyId: m.propertyId, additionalProperties: m.additionalProperties, actualType: m.actualType})), 'event');
    }
    InternalAvoLogger.logEventSent("Sign In Failed", {
      "Sign In Error": properties.signInError,
      "Email Input": properties.emailInput,
      "Client": sysClient,
      "Version": sysVersion,
      }, {});
  }

  // @ts-ignore
  let eventProperties: any = {};
  eventProperties["Sign In Error"] = properties.signInError;
  if (properties.emailInput !== undefined && properties.emailInput !== null) {
    eventProperties["Email Input"] = properties.emailInput;
  }
  eventProperties["Client"] = sysClient;
  eventProperties["Version"] = sysVersion;

  // @ts-ignore
  let userProperties: any = {};

  if (!__AVO_NOOP__) {
    return Promise.all([
      // report to Avo Inspector
      __INSPECTOR__ != null
        // @ts-ignore
        ? __INSPECTOR__._avoFunctionTrackSchemaFromEvent("Sign In Failed", {
        "Sign In Error": properties.signInError,
        "Email Input": properties.emailInput,
        "Client": sysClient,
        "Version": sysVersion,
        }, "7aa64217-bb89-44f5-9a68-f3bc0255a864", "ddc8c1ee0b5dbe58efd0d44d6d4dd8c2bc61bf1d64c7c8f74ea1f50d5b24b2ed")
      : Promise.resolve(),
      // destination CustomNodeJS
      CustomNodeJS.logEvent(properties.userId_, "Sign In Failed", (Object as any).assign({}, eventProperties)),
    ]);
  } else {
    // do nothing
    return new Promise((resolve: any) => { resolve(null); });
  }
}

export interface CliInvokedProperties {
  userId_: string;
  cliAction: CliActionValueType;
  schemaId: string;
  cliInvokedByCi: boolean;
  branchId: string;
  branchName: string;
  schemaName: string | null | undefined;
  force: boolean | null | undefined;
}
/**
 * Cli Invoked: Sent when any action is made in the CLI.
 *
 * @param properties the properties associatied with this event
 * @param properties.userId_: User Id is required for server sources.
 * @param properties.cliAction: no description
 * @param properties.schemaId: The ID of the schema that this event is related to.
 * @param properties.cliInvokedByCi: True iff process.env.CI is set.
 * @param properties.branchId: The ID of the branch that this event is related to.
 * @param properties.branchName: The name of the branch that this event is related to.
 * @param properties.schemaName: Name of the schema that this event is related to.
 * @param properties.force: Whether the command was called with --force parameter
 *
 * @see {@link https://www.avo.app/schemas/fwtXqAc0fCLy7b7oGW40/branches/ZbBYeviBz/events/qqpIQEK11}
 */
export function cliInvoked(properties: CliInvokedProperties) {
  // assert properties
  if (__AVO_ENV__ !== AvoEnv.Prod) {
    let messages: AvoAssertMessage[] = [];
    // debug console in Avo
    if (!__AVO_NOOP__) {
      _avo_invoke(__AVO_ENV__, "qqpIQEK11", "33cb14472604cc190f9a5added26d5adb763245b0dc9a2138dc2a4b2cc5a48ef", messages.map(m => Object.assign({}, {tag: m.tag, propertyId: m.propertyId, additionalProperties: m.additionalProperties, actualType: m.actualType})), 'event');
    }
    InternalAvoLogger.logEventSent("Cli Invoked", {
      "Cli Action": properties.cliAction,
      "Schema Id": properties.schemaId,
      "Cli Invoked by Ci": properties.cliInvokedByCi,
      "Branch Id": properties.branchId,
      "Branch Name": properties.branchName,
      "Schema Name": properties.schemaName,
      "Force": properties.force,
      "Client": sysClient,
      "Version": sysVersion,
      }, {});
  }

  // @ts-ignore
  let eventProperties: any = {};
  eventProperties["Cli Action"] = properties.cliAction;
  eventProperties["Schema Id"] = properties.schemaId;
  eventProperties["Cli Invoked by Ci"] = properties.cliInvokedByCi;
  eventProperties["Branch Id"] = properties.branchId;
  eventProperties["Branch Name"] = properties.branchName;
  if (properties.schemaName !== undefined && properties.schemaName !== null) {
    eventProperties["Schema Name"] = properties.schemaName;
  }
  if (properties.force !== undefined && properties.force !== null) {
    eventProperties["Force"] = properties.force;
  }
  eventProperties["Client"] = sysClient;
  eventProperties["Version"] = sysVersion;

  // @ts-ignore
  let userProperties: any = {};

  if (!__AVO_NOOP__) {
    return Promise.all([
      // report to Avo Inspector
      __INSPECTOR__ != null
        // @ts-ignore
        ? __INSPECTOR__._avoFunctionTrackSchemaFromEvent("Cli Invoked", {
        "Cli Action": properties.cliAction,
        "Schema Id": properties.schemaId,
        "Cli Invoked by Ci": properties.cliInvokedByCi,
        "Branch Id": properties.branchId,
        "Branch Name": properties.branchName,
        "Schema Name": properties.schemaName,
        "Force": properties.force,
        "Client": sysClient,
        "Version": sysVersion,
        }, "qqpIQEK11", "33cb14472604cc190f9a5added26d5adb763245b0dc9a2138dc2a4b2cc5a48ef")
      : Promise.resolve(),
      // destination CustomNodeJS
      CustomNodeJS.logEvent(properties.userId_, "Cli Invoked", (Object as any).assign({}, eventProperties)),
    ]);
  } else {
    // do nothing
    return new Promise((resolve: any) => { resolve(null); });
  }
}

export interface CliInstalledProperties {
  userId_: string;
  cliInvokedByCi: boolean;
}
/**
 * Cli Installed: Event sent when the CLI is successfully installed.
 *
 * @param properties the properties associatied with this event
 * @param properties.userId_: User Id is required for server sources.
 * @param properties.cliInvokedByCi: True iff process.env.CI is set.
 *
 * @see {@link https://www.avo.app/schemas/fwtXqAc0fCLy7b7oGW40/branches/ZbBYeviBz/events/JCwfVYXTS}
 */
export function cliInstalled(properties: CliInstalledProperties) {
  // assert properties
  if (__AVO_ENV__ !== AvoEnv.Prod) {
    let messages: AvoAssertMessage[] = [];
    // debug console in Avo
    if (!__AVO_NOOP__) {
      _avo_invoke(__AVO_ENV__, "JCwfVYXTS", "588b1f5190686099b083ad56d3fa443fd2f4c5558878d09a1ef5818f0c731f50", messages.map(m => Object.assign({}, {tag: m.tag, propertyId: m.propertyId, additionalProperties: m.additionalProperties, actualType: m.actualType})), 'event');
    }
    InternalAvoLogger.logEventSent("Cli Installed", {
      "Cli Invoked by Ci": properties.cliInvokedByCi,
      "Client": sysClient,
      "Version": sysVersion,
      }, {});
  }

  // @ts-ignore
  let eventProperties: any = {};
  eventProperties["Cli Invoked by Ci"] = properties.cliInvokedByCi;
  eventProperties["Client"] = sysClient;
  eventProperties["Version"] = sysVersion;

  // @ts-ignore
  let userProperties: any = {};

  if (!__AVO_NOOP__) {
    return Promise.all([
      // report to Avo Inspector
      __INSPECTOR__ != null
        // @ts-ignore
        ? __INSPECTOR__._avoFunctionTrackSchemaFromEvent("Cli Installed", {
        "Cli Invoked by Ci": properties.cliInvokedByCi,
        "Client": sysClient,
        "Version": sysVersion,
        }, "JCwfVYXTS", "588b1f5190686099b083ad56d3fa443fd2f4c5558878d09a1ef5818f0c731f50")
      : Promise.resolve(),
      // destination CustomNodeJS
      CustomNodeJS.logEvent(properties.userId_, "Cli Installed", (Object as any).assign({}, eventProperties)),
    ]);
  } else {
    // do nothing
    return new Promise((resolve: any) => { resolve(null); });
  }
}

export interface CliConflictResolveAttemptedProperties {
  userId_: string;
  cliInvokedByCi: boolean;
  schemaId: string;
  branchId: string;
  branchName: string;
  schemaName: string | null | undefined;
}
/**
 * Cli Conflict Resolve Attempted: No description
 *
 * @param properties the properties associatied with this event
 * @param properties.userId_: User Id is required for server sources.
 * @param properties.cliInvokedByCi: True iff process.env.CI is set.
 * @param properties.schemaId: The ID of the schema that this event is related to.
 * @param properties.branchId: The ID of the branch that this event is related to.
 * @param properties.branchName: The name of the branch that this event is related to.
 * @param properties.schemaName: Name of the schema that this event is related to.
 *
 * @see {@link https://www.avo.app/schemas/fwtXqAc0fCLy7b7oGW40/branches/ZbBYeviBz/events/Un5dTEMQYy}
 */
export function cliConflictResolveAttempted(
  properties: CliConflictResolveAttemptedProperties) {
  // assert properties
  if (__AVO_ENV__ !== AvoEnv.Prod) {
    let messages: AvoAssertMessage[] = [];
    // debug console in Avo
    if (!__AVO_NOOP__) {
      _avo_invoke(__AVO_ENV__, "Un5dTEMQYy", "c867f79479ce7c82d8c80d34ae1847e346f03cf8e742cf5706a2f18142f692a7", messages.map(m => Object.assign({}, {tag: m.tag, propertyId: m.propertyId, additionalProperties: m.additionalProperties, actualType: m.actualType})), 'event');
    }
    InternalAvoLogger.logEventSent("Cli Conflict Resolve Attempted", {
      "Cli Invoked by Ci": properties.cliInvokedByCi,
      "Schema Id": properties.schemaId,
      "Branch Id": properties.branchId,
      "Branch Name": properties.branchName,
      "Schema Name": properties.schemaName,
      "Client": sysClient,
      "Version": sysVersion,
      }, {});
  }

  // @ts-ignore
  let eventProperties: any = {};
  eventProperties["Cli Invoked by Ci"] = properties.cliInvokedByCi;
  eventProperties["Schema Id"] = properties.schemaId;
  eventProperties["Branch Id"] = properties.branchId;
  eventProperties["Branch Name"] = properties.branchName;
  if (properties.schemaName !== undefined && properties.schemaName !== null) {
    eventProperties["Schema Name"] = properties.schemaName;
  }
  eventProperties["Client"] = sysClient;
  eventProperties["Version"] = sysVersion;

  // @ts-ignore
  let userProperties: any = {};

  if (!__AVO_NOOP__) {
    return Promise.all([
      // report to Avo Inspector
      __INSPECTOR__ != null
        // @ts-ignore
        ? __INSPECTOR__._avoFunctionTrackSchemaFromEvent("Cli Conflict Resolve Attempted", {
        "Cli Invoked by Ci": properties.cliInvokedByCi,
        "Schema Id": properties.schemaId,
        "Branch Id": properties.branchId,
        "Branch Name": properties.branchName,
        "Schema Name": properties.schemaName,
        "Client": sysClient,
        "Version": sysVersion,
        }, "Un5dTEMQYy", "c867f79479ce7c82d8c80d34ae1847e346f03cf8e742cf5706a2f18142f692a7")
      : Promise.resolve(),
      // destination CustomNodeJS
      CustomNodeJS.logEvent(properties.userId_, "Cli Conflict Resolve Attempted", (Object as any).assign({}, eventProperties)),
    ]);
  } else {
    // do nothing
    return new Promise((resolve: any) => { resolve(null); });
  }
}

export interface CliConflictResolveFailedProperties {
  userId_: string;
  cliInvokedByCi: boolean;
  schemaId: string;
  schemaName: string | null | undefined;
  branchId: string;
  branchName: string;
}
/**
 * Cli Conflict Resolve Failed: No description
 *
 * @param properties the properties associatied with this event
 * @param properties.userId_: User Id is required for server sources.
 * @param properties.cliInvokedByCi: True iff process.env.CI is set.
 * @param properties.schemaId: The ID of the schema that this event is related to.
 * @param properties.schemaName: Name of the schema that this event is related to.
 * @param properties.branchId: The ID of the branch that this event is related to.
 * @param properties.branchName: The name of the branch that this event is related to.
 *
 * @see {@link https://www.avo.app/schemas/fwtXqAc0fCLy7b7oGW40/branches/ZbBYeviBz/events/4ZhoijIA2U}
 */
export function cliConflictResolveFailed(
  properties: CliConflictResolveFailedProperties) {
  // assert properties
  if (__AVO_ENV__ !== AvoEnv.Prod) {
    let messages: AvoAssertMessage[] = [];
    // debug console in Avo
    if (!__AVO_NOOP__) {
      _avo_invoke(__AVO_ENV__, "4ZhoijIA2U", "403808c3d3db8ed1d0a2298ac0c684fa8fcdc16c816f7bd878f136647aff8c00", messages.map(m => Object.assign({}, {tag: m.tag, propertyId: m.propertyId, additionalProperties: m.additionalProperties, actualType: m.actualType})), 'event');
    }
    InternalAvoLogger.logEventSent("Cli Conflict Resolve Failed", {
      "Cli Invoked by Ci": properties.cliInvokedByCi,
      "Schema Id": properties.schemaId,
      "Schema Name": properties.schemaName,
      "Branch Id": properties.branchId,
      "Branch Name": properties.branchName,
      "Client": sysClient,
      "Version": sysVersion,
      }, {});
  }

  // @ts-ignore
  let eventProperties: any = {};
  eventProperties["Cli Invoked by Ci"] = properties.cliInvokedByCi;
  eventProperties["Schema Id"] = properties.schemaId;
  if (properties.schemaName !== undefined && properties.schemaName !== null) {
    eventProperties["Schema Name"] = properties.schemaName;
  }
  eventProperties["Branch Id"] = properties.branchId;
  eventProperties["Branch Name"] = properties.branchName;
  eventProperties["Client"] = sysClient;
  eventProperties["Version"] = sysVersion;

  // @ts-ignore
  let userProperties: any = {};

  if (!__AVO_NOOP__) {
    return Promise.all([
      // report to Avo Inspector
      __INSPECTOR__ != null
        // @ts-ignore
        ? __INSPECTOR__._avoFunctionTrackSchemaFromEvent("Cli Conflict Resolve Failed", {
        "Cli Invoked by Ci": properties.cliInvokedByCi,
        "Schema Id": properties.schemaId,
        "Schema Name": properties.schemaName,
        "Branch Id": properties.branchId,
        "Branch Name": properties.branchName,
        "Client": sysClient,
        "Version": sysVersion,
        }, "4ZhoijIA2U", "403808c3d3db8ed1d0a2298ac0c684fa8fcdc16c816f7bd878f136647aff8c00")
      : Promise.resolve(),
      // destination CustomNodeJS
      CustomNodeJS.logEvent(properties.userId_, "Cli Conflict Resolve Failed", (Object as any).assign({}, eventProperties)),
    ]);
  } else {
    // do nothing
    return new Promise((resolve: any) => { resolve(null); });
  }
}

export interface CliConflictResolveSucceededProperties {
  userId_: string;
  cliInvokedByCi: boolean;
  schemaId: string;
  schemaName: string | null | undefined;
  branchId: string;
  branchName: string;
}
/**
 * Cli Conflict Resolve Succeeded: No description
 *
 * @param properties the properties associatied with this event
 * @param properties.userId_: User Id is required for server sources.
 * @param properties.cliInvokedByCi: True iff process.env.CI is set.
 * @param properties.schemaId: The ID of the schema that this event is related to.
 * @param properties.schemaName: Name of the schema that this event is related to.
 * @param properties.branchId: The ID of the branch that this event is related to.
 * @param properties.branchName: The name of the branch that this event is related to.
 *
 * @see {@link https://www.avo.app/schemas/fwtXqAc0fCLy7b7oGW40/branches/ZbBYeviBz/events/yj_554q43i}
 */
export function cliConflictResolveSucceeded(
  properties: CliConflictResolveSucceededProperties) {
  // assert properties
  if (__AVO_ENV__ !== AvoEnv.Prod) {
    let messages: AvoAssertMessage[] = [];
    // debug console in Avo
    if (!__AVO_NOOP__) {
      _avo_invoke(__AVO_ENV__, "yj_554q43i", "a4a180d66deeb76b91d67098746764905c5b37c201019c26da254a8358110f9f", messages.map(m => Object.assign({}, {tag: m.tag, propertyId: m.propertyId, additionalProperties: m.additionalProperties, actualType: m.actualType})), 'event');
    }
    InternalAvoLogger.logEventSent("Cli Conflict Resolve Succeeded", {
      "Cli Invoked by Ci": properties.cliInvokedByCi,
      "Schema Id": properties.schemaId,
      "Schema Name": properties.schemaName,
      "Branch Id": properties.branchId,
      "Branch Name": properties.branchName,
      "Client": sysClient,
      "Version": sysVersion,
      }, {});
  }

  // @ts-ignore
  let eventProperties: any = {};
  eventProperties["Cli Invoked by Ci"] = properties.cliInvokedByCi;
  eventProperties["Schema Id"] = properties.schemaId;
  if (properties.schemaName !== undefined && properties.schemaName !== null) {
    eventProperties["Schema Name"] = properties.schemaName;
  }
  eventProperties["Branch Id"] = properties.branchId;
  eventProperties["Branch Name"] = properties.branchName;
  eventProperties["Client"] = sysClient;
  eventProperties["Version"] = sysVersion;

  // @ts-ignore
  let userProperties: any = {};

  if (!__AVO_NOOP__) {
    return Promise.all([
      // report to Avo Inspector
      __INSPECTOR__ != null
        // @ts-ignore
        ? __INSPECTOR__._avoFunctionTrackSchemaFromEvent("Cli Conflict Resolve Succeeded", {
        "Cli Invoked by Ci": properties.cliInvokedByCi,
        "Schema Id": properties.schemaId,
        "Schema Name": properties.schemaName,
        "Branch Id": properties.branchId,
        "Branch Name": properties.branchName,
        "Client": sysClient,
        "Version": sysVersion,
        }, "yj_554q43i", "a4a180d66deeb76b91d67098746764905c5b37c201019c26da254a8358110f9f")
      : Promise.resolve(),
      // destination CustomNodeJS
      CustomNodeJS.logEvent(properties.userId_, "Cli Conflict Resolve Succeeded", (Object as any).assign({}, eventProperties)),
    ]);
  } else {
    // do nothing
    return new Promise((resolve: any) => { resolve(null); });
  }
}

export default {
  AvoEnv,
  initAvo,
  setSystemProperties,
  avoInspectorApiKey,
  SignInError,
  Client,
  AuthenticationMethod,
  CliAction,
  signedIn,
  signInFailed,
  cliInvoked,
  cliInstalled,
  cliConflictResolveAttempted,
  cliConflictResolveFailed,
  cliConflictResolveSucceeded,
}

// AVOMODULEMAP:"Avo"
// AVOEVENTMAP:["signedIn","signInFailed","cliInvoked","cliInstalled","cliConflictResolveAttempted","cliConflictResolveFailed","cliConflictResolveSucceeded"]
